

<div class="box">
  <div class="top-fixed">
    <div class="word" style="display: flex; justify-content: space-between; align-items: baseline;">
      <span>{{Word}}</span>
      <span id="debug-counter" style="display:none;"></span>
    </div>
    <div class="phonetic transparent">{{IPA}}</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/anki-storage@latest/dist/anki-storage.umd.js" onload="window.ankiStorageLoaded=true"></script>

<script>
// ===== OneMoreTurn MVP =====
(async function() {
  // Wait a bit for AnkiStorage to load
  await new Promise(resolve => setTimeout(resolve, 100));

  // Detect platform and choose storage
  var ua = navigator.userAgent;
  var isAnkiDroid = ua.indexOf('AnkiDroid') !== -1;
  var isAnkiMobile = ua.indexOf('AnkiMobile') !== -1;
  var isAndroid = /Android/i.test(ua);
  var isMobile = isAnkiDroid || isAnkiMobile || /Mobile|Android|iPhone|iPad/i.test(ua);

  var storage = localStorage; // default
  var storageType = 'localStorage';

  // Show UA for debugging
  var uaShort = ua.substring(0, 60);
  var storageInfo = 'UA:' + uaShort + '... AND:' + (isAndroid ? 'Y' : 'N') + ' M:' + (isMobile ? 'Y' : 'N') + ' LIB:' + (typeof AnkiStorage !== 'undefined' ? 'Y' : 'N');

  // Platform-specific storage strategy:
  // - Android with anki-storage: use anki-storage (persistent across app restarts)
  // - iOS/Desktop: sessionStorage (persistent during study session)
  if (isAndroid && typeof AnkiStorage !== 'undefined') {
    // AnkiDroid: use anki-storage for full persistence
    try {
      var as = await AnkiStorage.getAnkiStorage();
      storage = {
        getItem: function(key) { return as.localStorage.getItem(key); },
        setItem: function(key, val) { return as.localStorage.setItem(key, val); }
      };
      storageType = 'anki-storage';
      storageInfo += ' ST:AS';
    } catch (e) {
      storageInfo += ' ST:SS ERR:' + e.message.substring(0, 20);
      // Fallback to sessionStorage
      storage = sessionStorage;
      storageType = 'sessionStorage';
    }
  } else {
    // iOS and Desktop: use sessionStorage (session-level persistence)
    storage = sessionStorage;
    storageType = 'sessionStorage';
    storageInfo += ' ST:SS';
  }

  // Helper to get value (handles both sync and async)
  async function getValue(key, defaultVal) {
    try {
      var val = await storage.getItem(key);
      return val || defaultVal;
    } catch (e) {
      return storage.getItem(key) || defaultVal;
    }
  }

  // Helper to set value (handles both sync and async)
  async function setValue(key, val) {
    try {
      await storage.setItem(key, val);
    } catch (e) {
      storage.setItem(key, val);
    }
  }

  // Read configuration from storage
  // AnkiDroid: use anki-storage for config (localStorage isolated between front/back)
  // Desktop/iOS: use localStorage for config (shared between front/back)
  var configStorage = (storageType === 'anki-storage') ? storage : localStorage;

  async function getConfig(key, defaultVal) {
    if (storageType === 'anki-storage') {
      // Android: async API
      try {
        var val = await configStorage.getItem(key);
        return val || defaultVal;
      } catch (e) {
        return configStorage.getItem(key) || defaultVal;
      }
    } else {
      // Desktop/iOS: sync API
      return configStorage.getItem(key) || defaultVal;
    }
  }

  var hitMotivation = parseInt(await getConfig('mneme_hit_motivation', '1'));
  var quickHit = JSON.parse(await getConfig('mneme_quick_hit', '[10,1500,50,40]'));
  var comboHit = JSON.parse(await getConfig('mneme_combo_hit', '[50,3000,50,50]'));
  var quickHitMessages = JSON.parse(await getConfig('mneme_quick_hit_messages', '["NICE WORK|{count}"]'));
  var comboHitMessages = JSON.parse(await getConfig('mneme_combo_hit_messages', '["NICE WORK|{count}"]'));

  var quickTrigger = quickHit[0];
  var quickDuration = quickHit[1];
  var quickPosition = quickHit[2];
  var quickFontSize = quickHit[3] || 40;
  var comboTrigger = comboHit[0];
  var comboDuration = comboHit[1];
  var comboPosition = comboHit[2];
  var comboFontSize = comboHit[3] || 50;

  if (!hitMotivation) return;

  function getRandomText(textArray) {
    if (!Array.isArray(textArray) || textArray.length === 0) {
      return "NICE WORK|{count}";
    }
    var randomIndex = Math.floor(Math.random() * textArray.length);
    return textArray[randomIndex];
  }

  // Parse message format: subtitle|title
  function parseMessage(template, count) {
    const selectedText = getRandomText(template);

    const processed = selectedText.replace(/\{count\}/g, count);

    // Split into two parts using |: subtitle|title
    const parts = processed.split('|');
    if (parts.length >= 2) {
      return {
        type: 'hierarchy',
        subtitle: parts[0] ? parts[0].trim() : '',
        title: parts[1] ? parts[1].trim() : ''
      };
    } else {
      return { type: 'single', content: processed.trim() };
    }
  }

  // Center popup display - hierarchical design
  function showCenterPopup(message, isLong = false, count = 1) {
    const popup = document.createElement('div');
    const baseFontSize = isLong ? comboFontSize : quickFontSize;
    const duration = isLong ? comboDuration : quickDuration;
    const position = isLong ? comboPosition : quickPosition;

    const parsed = parseMessage(message, count);

    if (parsed.type === 'single') {
      popup.innerHTML = parsed.content;
      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        font-size: ${baseFontSize * 2}px;
        font-weight: bold;
        color: var(--text-primary, #333);
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;
    } else {
      popup.innerHTML = `
        <div class="milestone-subtitle">${parsed.subtitle}</div>
        <div class="milestone-title">${parsed.title}</div>
      `;

      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;

      // Set different multiplier ratios based on type
      const subtitleMultiplier = isLong ? 0.7 : 0.5;  // Combo subtitle slightly larger
      const titleMultiplier = isLong ? 2.2 : 1.8;     // Combo title larger

      // Set subtitle style: small, thin, gray
      const subtitle = popup.querySelector('.milestone-subtitle');
      if (subtitle) {
        subtitle.style.cssText = `
          font-size: ${baseFontSize * subtitleMultiplier}px;
          font-weight: normal;
          color: var(--text-secondary, #666);
          letter-spacing: 2px;
          text-transform: uppercase;
          margin-bottom: 10px;
          animation: subtitleAppear 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.1s;
          opacity: 0;
        `;
      }

      // Set title style: large, bold, white
      const title = popup.querySelector('.milestone-title');
      if (title) {
        title.style.cssText = `
          font-size: ${baseFontSize * titleMultiplier}px;
          font-weight: bold;
          color: var(--text-primary, #333);
          line-height: 1.1;
          animation: titleAppear 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.3s;
          opacity: 0;
        `;
      }
    }

    document.body.appendChild(popup);

    setTimeout(() => {
      if (popup.parentNode) {
        popup.parentNode.removeChild(popup);
      }
    }, duration);
  }

  function getResetKey() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // If current time is before 4 AM, use previous day's date as reset key
    if (now.getHours() < 4) {
      today.setDate(today.getDate() - 1);
    }

    return today.toDateString();
  }

  async function checkAndResetCount() {
    const currentResetKey = getResetKey();
    const lastResetKey = await getValue('omt_last_reset', '');

    if (currentResetKey !== lastResetKey) {
      // New day (after 4 AM), reset counter
      await setValue('omt_count', '0');
      await setValue('omt_last_reset', currentResetKey);
      return 0;
    }

    return parseInt(await getValue('omt_count', '0'), 10);
  }

  async function getCount() {
    return await checkAndResetCount();
  }

  async function setCount(count) {
    await setValue('omt_count', count.toString());
  }

  // Trigger count when front loads (indicates starting to learn new card)
  const currentCount = await getCount() + 1;
  await setCount(currentCount);

  // Debug mode: Display counter (controlled by back.html debugMode setting)
  var debugModeEnabled = parseInt(await getConfig('mneme_debug_mode', '0'));
  if (debugModeEnabled === 1) {
    var debugCounter = document.getElementById('debug-counter');
    if (debugCounter) {
      // ðŸ”’ = anki-storage (AnkiDroid full persistence)
      // ðŸ“¦ = sessionStorage (iOS/Desktop session persistence)
      var storageIndicator = storageType === 'anki-storage' ? 'ðŸ”’' : 'ðŸ“¦';
      debugCounter.textContent = currentCount + ' ' + storageIndicator + ' ' + storageInfo;
      debugCounter.style.display = 'inline';
      debugCounter.style.fontSize = '0.3em';
      debugCounter.style.color = 'var(--text-secondary, #999)';
      debugCounter.style.fontWeight = 'normal';
      debugCounter.style.opacity = '0.6';
      debugCounter.style.marginLeft = '0.5em';
    }
  }

  // Check if combo trigger is activated (higher priority)
  if (currentCount % comboTrigger === 0) {
    showCenterPopup(comboHitMessages, true, currentCount);
  } else if (currentCount % quickTrigger === 0) {
    showCenterPopup(quickHitMessages, false, currentCount);
  }
})();
</script>
