

<div class="box">
  <div class="top-fixed">
    <div class="word" style="display: flex; justify-content: space-between; align-items: baseline;">
      <span>{{Word}}</span>
      <span id="debug-counter" style="display:none;"></span>
    </div>
    <div class="phonetic transparent">{{IPA}}</div>
  </div>
</div>

<script>
// ===== OneMoreTurn MVP =====
(async function() {
  var ua = navigator.userAgent;
  var isAnkiDroid = ua.indexOf('AnkiDroid') !== -1;
  var isAnkiMobile = ua.indexOf('AnkiMobile') !== -1;
  var isAndroid = /Android/i.test(ua);
  var isMobile = isAnkiDroid || isAnkiMobile || /Mobile|Android|iPhone|iPad/i.test(ua);
  var storage = window.sessionStorage;
  var storageType = 'sessionStorage';
  var storageIndicator = 'ðŸ“¦';

  function updateDebugDisplay(line) {
    if (debugModeSetting !== 1) return;
    var debugCounter = document.getElementById('debug-counter');
    if (!debugCounter) return;
    debugCounter.textContent = line;
    debugCounter.style.display = 'inline';
    debugCounter.style.fontSize = '0.3em';
    debugCounter.style.color = 'var(--text-secondary, #999)';
    debugCounter.style.fontWeight = 'normal';
    debugCounter.style.opacity = '0.6';
    debugCounter.style.marginLeft = '0.5em';
  }

  var uaShort = ua.substring(0, 60);
  var storageInfo = 'UA:' + uaShort + '... AND:' + (isAndroid ? 'Y' : 'N') + ' M:' + (isMobile ? 'Y' : 'N') + ' ST:SS';

  async function getValue(key, defaultVal) {
    try {
      var val = storage.getItem(key);
      return val === null ? defaultVal : val;
    } catch (e) {
      return defaultVal;
    }
  }

  async function setValue(key, val) {
    try {
      storage.setItem(key, val);
    } catch (e) {}
  }

  var configStorage = localStorage;

  async function getConfig(key, defaultVal) {
    return configStorage.getItem(key) || defaultVal;
  }

  var debugModeSetting = parseInt(await getConfig('mneme_debug_mode', '0'), 10);
  var hitMotivation = parseInt(await getConfig('mneme_hit_motivation', '1'), 10);
  var quickHit = JSON.parse(await getConfig('mneme_quick_hit', '[10,1500,50,40]'));
  var comboHit = JSON.parse(await getConfig('mneme_combo_hit', '[50,3000,50,50]'));
  var quickHitMessages = JSON.parse(await getConfig('mneme_quick_hit_messages', '["NICE WORK|{count}"]'));
  var comboHitMessages = JSON.parse(await getConfig('mneme_combo_hit_messages', '["NICE WORK|{count}"]'));

  var quickTrigger = quickHit[0];
  var quickDuration = quickHit[1];
  var quickPosition = quickHit[2];
  var quickFontSize = quickHit[3] || 40;
  var comboTrigger = comboHit[0];
  var comboDuration = comboHit[1];
  var comboPosition = comboHit[2];
  var comboFontSize = comboHit[3] || 50;

  if (!hitMotivation) return;

  function getRandomText(textArray) {
    if (!Array.isArray(textArray) || textArray.length === 0) {
      return "NICE WORK|{count}";
    }
    var randomIndex = Math.floor(Math.random() * textArray.length);
    return textArray[randomIndex];
  }

  // Parse message format: subtitle|title
  function parseMessage(template, count) {
    const selectedText = getRandomText(template);

    const processed = selectedText.replace(/\{count\}/g, count);

    // Split into two parts using |: subtitle|title
    const parts = processed.split('|');
    if (parts.length >= 2) {
      return {
        type: 'hierarchy',
        subtitle: parts[0] ? parts[0].trim() : '',
        title: parts[1] ? parts[1].trim() : ''
      };
    } else {
      return { type: 'single', content: processed.trim() };
    }
  }

  // Center popup display - hierarchical design
  function showCenterPopup(message, isLong = false, count = 1) {
    const popup = document.createElement('div');
    const baseFontSize = isLong ? comboFontSize : quickFontSize;
    const duration = isLong ? comboDuration : quickDuration;
    const position = isLong ? comboPosition : quickPosition;

    const parsed = parseMessage(message, count);

    if (parsed.type === 'single') {
      popup.innerHTML = parsed.content;
      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        font-size: ${baseFontSize * 2}px;
        font-weight: bold;
        color: var(--text-primary, #333);
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;
    } else {
      popup.innerHTML = `
        <div class="milestone-subtitle">${parsed.subtitle}</div>
        <div class="milestone-title">${parsed.title}</div>
      `;

      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;

      // Set different multiplier ratios based on type
      const subtitleMultiplier = isLong ? 0.7 : 0.5;  // Combo subtitle slightly larger
      const titleMultiplier = isLong ? 2.2 : 1.8;     // Combo title larger

      // Set subtitle style: small, thin, gray
      const subtitle = popup.querySelector('.milestone-subtitle');
      if (subtitle) {
        subtitle.style.cssText = `
          font-size: ${baseFontSize * subtitleMultiplier}px;
          font-weight: normal;
          color: var(--text-secondary, #666);
          letter-spacing: 2px;
          text-transform: uppercase;
          margin-bottom: 10px;
          animation: subtitleAppear 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.1s;
          opacity: 0;
        `;
      }

      // Set title style: large, bold, white
      const title = popup.querySelector('.milestone-title');
      if (title) {
        title.style.cssText = `
          font-size: ${baseFontSize * titleMultiplier}px;
          font-weight: bold;
          color: var(--text-primary, #333);
          line-height: 1.1;
          animation: titleAppear 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.3s;
          opacity: 0;
        `;
      }
    }

    document.body.appendChild(popup);

    setTimeout(() => {
      if (popup.parentNode) {
        popup.parentNode.removeChild(popup);
      }
    }, duration);
  }

  function getResetKey() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // If current time is before 4 AM, use previous day's date as reset key
    if (now.getHours() < 4) {
      today.setDate(today.getDate() - 1);
    }

    return today.toDateString();
  }

  async function checkAndResetCount() {
    const currentResetKey = getResetKey();
    const lastResetKey = await getValue('omt_last_reset', '');

    if (currentResetKey !== lastResetKey) {
      await setValue('omt_last_reset', currentResetKey);
      await setValue('omt_count', '0');
      return 0;
    }

    return parseInt(await getValue('omt_count', '0'), 10) || 0;
  }

  async function getCount() {
    return await checkAndResetCount();
  }

  async function setCount(count) {
    await setValue('omt_count', count.toString());
  }

  // ===== Deduplication: Track last 4 unique words =====
  async function getRecentWords() {
    const wordsJson = await getValue('omt_recent_words', '[]');
    try {
      return JSON.parse(wordsJson);
    } catch (e) {
      return [];
    }
  }

  async function isRecentWord(word) {
    const recentWords = await getRecentWords();
    return recentWords.indexOf(word) !== -1;
  }

  async function addRecentWord(word) {
    let recentWords = await getRecentWords();

    // Remove word if already exists (to maintain uniqueness)
    const index = recentWords.indexOf(word);
    if (index !== -1) {
      recentWords.splice(index, 1);
    }

    // Add new word to the end
    recentWords.push(word);

    // Keep only last 4 unique words
    if (recentWords.length > 4) {
      recentWords.shift();
    }

    await setValue('omt_recent_words', JSON.stringify(recentWords));
  }

  // Get current word from template field
  const currentWord = '{{Word}}';

  // Trigger count only if this is a new word (not recently seen)
  if (!await isRecentWord(currentWord)) {
    const currentCount = await getCount() + 1;
    await setCount(currentCount);
    await addRecentWord(currentWord);

    // Debug mode: Display counter (controlled by back.html debugMode setting)
    updateDebugDisplay(currentCount + ' ' + storageIndicator + ' ' + storageInfo);

    // Check if combo trigger is activated (higher priority)
    if (currentCount % comboTrigger === 0) {
      showCenterPopup(comboHitMessages, true, currentCount);
    } else if (currentCount % quickTrigger === 0) {
      showCenterPopup(quickHitMessages, false, currentCount);
    }
  } else {
    // Debug mode: Show skipped message for duplicate word
    const currentCount = await getCount();
    updateDebugDisplay(currentCount + ' [SKIP] ' + storageIndicator);
  }
  })();
</script>
