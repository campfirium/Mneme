<script>
(function() {
  var host = (window.location && window.location.hostname) || '';
  var isAnkiWeb = /anki(user|web)\.net$/i.test(host);
  var root = document.documentElement;
  if (isAnkiWeb && root && !root.classList.contains('ankiweb')) {
    root.classList.add('ankiweb');
  }
  window.mnemeEnv = window.mnemeEnv || {};
  window.mnemeEnv.isAnkiWeb = isAnkiWeb;
})();
</script>

<div class="box">
  <div class="top-fixed">
    <div class="word" style="display: flex; justify-content: space-between; align-items: baseline;">
      <span>{{Word}}</span>
      <span id="debug-counter" style="display:none;"></span>
    </div>
    <div class="phonetic transparent">{{IPA}}</div>
  </div>
  <div id="storage-panel" style="margin-top:1.2em;padding:0.6em 0.4em;border-radius:0.6em;background:rgba(0,0,0,0.04);color:var(--text-secondary,#666);font-size:0.75em;line-height:1.4;min-height:3.2em;display:flex;flex-direction:column;gap:0.4em;">
    <div id="storage-summary" style="font-weight:600;text-transform:uppercase;letter-spacing:0.05em;"></div>
    <div id="storage-log" style="display:flex;flex-direction:column;gap:0.2em;font-size:0.7em;color:var(--text-secondary,#888);"></div>
  </div>
</div>

<script>
// ===== OneMoreTurn MVP =====
(async function() {
  function sleep(ms) {
    return new Promise(function(resolve) { setTimeout(resolve, ms); });
  }

  function ensureAnkiStorageBridge() {
    if (window.mnemeAnkiStorageLoading) return;
    window.mnemeAnkiStorageLoading = true;
    var script = document.createElement('script');
    script.src = 'https://campfirium.github.io/Mneme/anki-storage.umd.js';
    script.async = true;
    script.onload = function() { window.ankiStorageLoaded = true; };
    script.onerror = function() { window.ankiStorageLoaded = false; window.mnemeAnkiStorageLoading = false; };
    document.head.appendChild(script);
  }

  ensureAnkiStorageBridge();

  async function waitForAnkiStorage(timeoutMs) {
    var elapsed = 0;
    var interval = 100;
    while (elapsed < timeoutMs) {
      if (window.ankiStorageLoaded === true || typeof AnkiStorage !== 'undefined') {
        return true;
      }
      await sleep(interval);
      elapsed += interval;
    }
    return window.ankiStorageLoaded === true || typeof AnkiStorage !== 'undefined';
  }

  var ua = navigator.userAgent;
  var isAnkiDroid = ua.indexOf('AnkiDroid') !== -1;
  var isAndroid = /Android/i.test(ua);
  var storage = window.sessionStorage;
  var REMOTE_PENDING_KEY = 'omt_remote_pending';
  var LOCAL_COUNT_KEY = 'omt_count';
  var REMOTE_BASELINE_KEY = 'omt_remote_baseline_applied';
  var currentTotal = loadLocalCount();
  var hasAppliedRemoteBaseline = storage.getItem(REMOTE_BASELINE_KEY) === '1';
  var diagnosticsPanel = document.getElementById('storage-panel');
  var storageSummaryEl = document.getElementById('storage-summary');
  var storageLogEl = document.getElementById('storage-log');
  var logEntries = [];
  var remoteLastKnownCount = null;

  function updateStorageSummary(note) {
    if (!diagnosticsPanel || !storageSummaryEl) return;
    var summaryParts = [];
    summaryParts.push('Session üì¶ ' + currentTotal);
    if (isAndroid) {
      var remoteLabel;
      if (remoteReady) {
        var remoteText = remoteLastKnownCount !== null ? remoteLastKnownCount : 'ÂêåÊ≠•‰∏≠';
        remoteLabel = 'Anki üîí ' + remoteText;
      } else {
        remoteLabel = 'Anki ‚Ä¶ Êú™ËøûÊé•';
      }
      summaryParts.push(remoteLabel);
    } else {
      summaryParts.push('Anki ‚õî ‰∏çÈÄÇÁî®');
    }
    if (note) summaryParts.push(note);
    if (storageSummaryEl) {
      storageSummaryEl.textContent = summaryParts.join(' | ');
    }
  }

  function appendLog(message) {
    if (!storageLogEl) return;
    var stamp = new Date();
    var hh = stamp.getHours().toString().padStart(2, '0');
    var mm = stamp.getMinutes().toString().padStart(2, '0');
    var ss = stamp.getSeconds().toString().padStart(2, '0');
    logEntries.push(hh + ':' + mm + ':' + ss + ' ¬∑ ' + message);
    if (logEntries.length > 8) {
      logEntries.shift();
    }
    storageLogEl.innerHTML = logEntries.map(function(entry) {
      return '<div>' + entry + '</div>';
    }).join('');
  }

  var remoteStorage = null;
  var remoteReady = false;
  var remoteRetryHandle = null;
  var pendingRemoteUpdates = loadPendingRemoteUpdates();
  var remoteSyncInProgress = false;
  var androidSessionFallbackActive = false;

  function activateAndroidSessionFallback() {
    if (!isAndroid) return;
    androidSessionFallbackActive = true;
  }

  function clearAndroidSessionFallback() {
    if (!isAndroid) return;
    androidSessionFallbackActive = false;
  }

  function loadLocalCount() {
    var stored = 0;
    try {
      stored = parseInt(storage.getItem(LOCAL_COUNT_KEY) || '0', 10) || 0;
    } catch (e) {
      stored = 0;
    }
    return stored;
  }

  function persistLocalCount() {
    try {
      storage.setItem(LOCAL_COUNT_KEY, currentTotal.toString());
    } catch (e) {}
  }

  function loadPendingRemoteUpdates() {
    if (!isAndroid) return {};
    try {
      var raw = storage.getItem(REMOTE_PENDING_KEY);
      if (!raw) return {};
      var parsed = JSON.parse(raw);
      return (parsed && typeof parsed === 'object') ? parsed : {};
    } catch (e) {
      return {};
    }
  }

  function persistPendingRemoteUpdates() {
    if (!isAndroid) return;
    try {
      if (!pendingRemoteUpdates || Object.keys(pendingRemoteUpdates).length === 0) {
        storage.removeItem(REMOTE_PENDING_KEY);
      } else {
        storage.setItem(REMOTE_PENDING_KEY, JSON.stringify(pendingRemoteUpdates));
      }
    } catch (e) {}
  }

  function shouldSyncKey(key) {
    return key === LOCAL_COUNT_KEY || key === 'omt_last_reset' || key === 'omt_recent_words';
  }

  function queueRemoteUpdate(key, val) {
    if (!isAndroid) return;
    if (key === LOCAL_COUNT_KEY && !hasAppliedRemoteBaseline) {
      return;
    }
    pendingRemoteUpdates[key] = val;
    persistPendingRemoteUpdates();
    flushPendingRemoteUpdates();
  }

  async function flushPendingRemoteUpdates() {
    if (!remoteReady || remoteSyncInProgress) return;
    var keys = Object.keys(pendingRemoteUpdates);
    if (keys.length === 0) return;
    remoteSyncInProgress = true;
    var syncedCount = false;
    try {
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        var value = pendingRemoteUpdates[k];
        try {
          await remoteStorage.setItem(k, value);
          if (k === LOCAL_COUNT_KEY) {
            var parsed = parseInt(value, 10);
            remoteLastKnownCount = isNaN(parsed) ? remoteLastKnownCount : parsed;
            syncedCount = true;
          }
        } catch (inner) {
          throw inner;
        }
      }
      pendingRemoteUpdates = {};
      persistPendingRemoteUpdates();
      if (syncedCount) {
        appendLog('Â∑≤ÂêåÊ≠• anki-storage ËÆ°Êï∞ -> ' + (remoteLastKnownCount !== null ? remoteLastKnownCount : 'Êú™Áü•'));
        updateStorageSummary();
      }
    } catch (err) {
      remoteReady = false;
      appendLog('Anki ËÆ°Êï∞ÔºöËøúÁ´ØÂêåÊ≠•Â§±Ë¥• - ' + (err && err.message ? err.message : 'unknown'));
      scheduleRemoteRetry();
    } finally {
      remoteSyncInProgress = false;
    }
  }

  function scheduleRemoteRetry() {
    if (!isAndroid || remoteRetryHandle) return;
    activateAndroidSessionFallback();
    remoteRetryHandle = setTimeout(async function() {
      remoteRetryHandle = null;
      await initRemoteBridge();
    }, 3000);
    appendLog('Anki ËÆ°Êï∞ÔºöËøûÊé•‰∏≠Êñ≠ÔºåÁ≠âÂæÖÈáçËØï');
    updateStorageSummary('Á≠âÂæÖ anki-storage');
  }

  async function ensureRemoteResetState() {
    if (!remoteStorage) return;
    var currentResetKey = getResetKey();
    try {
      var remoteResetKey = await remoteStorage.getItem('omt_last_reset');
      if (!remoteResetKey) {
        await remoteStorage.setItem('omt_last_reset', currentResetKey);
        return;
      }
      if (remoteResetKey !== currentResetKey) {
        appendLog('Anki ËÆ°Êï∞ÔºöÊ£ÄÊµãÂà∞Êñ∞‰∏ÄÂ§©ÔºåÈáçÁΩÆËøúÁ´ØËÆ°Êï∞');
        await remoteStorage.setItem('omt_last_reset', currentResetKey);
        await remoteStorage.setItem(LOCAL_COUNT_KEY, '0');
        remoteLastKnownCount = 0;
      }
    } catch (err) {
      throw err;
    }
  }

  async function syncFromRemote() {
    if (!remoteStorage) return;
    try {
      var remoteReset = await remoteStorage.getItem('omt_last_reset');
      if (remoteReset) {
        storage.setItem('omt_last_reset', remoteReset);
      }
      var remoteWords = await remoteStorage.getItem('omt_recent_words');
      if (remoteWords) {
        storage.setItem('omt_recent_words', remoteWords);
      }
      var remoteCountStr = await remoteStorage.getItem(LOCAL_COUNT_KEY);
      var remoteCount = parseInt(remoteCountStr || '0', 10);
      if (isNaN(remoteCount)) remoteCount = 0;
      remoteLastKnownCount = remoteCount;

      if (!hasAppliedRemoteBaseline) {
        var localBefore = currentTotal;
        currentTotal = remoteCount + localBefore;
        persistLocalCount();
        storage.setItem(REMOTE_BASELINE_KEY, '1');
        hasAppliedRemoteBaseline = true;
        if (currentTotal !== remoteCount) {
          pendingRemoteUpdates[LOCAL_COUNT_KEY] = currentTotal.toString();
          persistPendingRemoteUpdates();
        }
        appendLog('Êé•Êî∂ anki-storage Âü∫Á∫ø ' + remoteCount + 'Ôºå‰ºöËØùÁ¥ØËÆ° -> ' + currentTotal);
      } else if (remoteCount > currentTotal) {
        currentTotal = remoteCount;
        persistLocalCount();
        appendLog('ËøúÁ´ØËÆ°Êï∞Ë¶ÜÁõñ -> ' + currentTotal);
      }
      updateStorageSummary('Â∑≤ÂêåÊ≠•');
    } catch (err) {
      remoteReady = false;
      appendLog('Anki ËÆ°Êï∞ÔºöËøúÁ´ØÂêåÊ≠•Â§±Ë¥• - ' + (err && err.message ? err.message : 'unknown'));
      scheduleRemoteRetry();
    }
  }

  async function initRemoteBridge() {
    if (!isAndroid) {
      appendLog('Anki ËÆ°Êï∞ÔºöÈùû Android Âπ≥Âè∞ÔºåË∑≥Ëøá');
      return;
    }
    appendLog('Anki ËÆ°Êï∞ÔºöÂºÄÂßãËøûÊé• ‚Ä¶');
    var loaded = await waitForAnkiStorage(1500);
    if (!loaded || typeof AnkiStorage === 'undefined') {
      appendLog('Anki ËÆ°Êï∞ÔºöÊ°•Êé•Êú™Â∞±Áª™ÔºåÁ®çÂêéÈáçËØï');
      scheduleRemoteRetry();
      return;
    }
    try {
      var ankiInstance = await AnkiStorage.getAnkiStorage();
      remoteStorage = ankiInstance.localStorage;
      await ensureRemoteResetState();
      await syncFromRemote();
      remoteReady = true;
      clearAndroidSessionFallback();
      appendLog('Anki ËÆ°Êï∞ÔºöËøûÊé•ÊàêÂäü');
      flushPendingRemoteUpdates();
      updateStorageSummary();
    } catch (err) {
      remoteReady = false;
      appendLog('Anki ËÆ°Êï∞ÔºöËøûÊé•Â§±Ë¥• - ' + (err && err.message ? err.message : 'unknown'));
      scheduleRemoteRetry();
    }
  }

  async function getValue(key, defaultVal) {
    try {
      var val = storage.getItem(key);
      return val === null ? defaultVal : val;
    } catch (e) {
      return defaultVal;
    }
  }

  async function setValue(key, val) {
    try {
      storage.setItem(key, val);
    } catch (e) {}
    if (shouldSyncKey(key)) {
      queueRemoteUpdate(key, val);
    }
  }

  async function getConfig(key, defaultVal) {
    try {
      var val = window.sessionStorage.getItem(key);
      if (val !== null && typeof val !== 'undefined' && val !== '') {
        return val;
      }
    } catch (e) {}
    return defaultVal;
  }

  updateStorageSummary();
  appendLog('Session ËÆ°Êï∞ÂàùÂßãÂåñ -> ' + currentTotal);
  appendLog(isAndroid ? 'Anki ËÆ°Êï∞ÔºöÁ≠âÂæÖËøûÊé•' : 'Anki ËÆ°Êï∞Ôºö‰∏çÈÄÇÁî®');
  var hitMotivation = parseInt(await getConfig('mneme_hit_motivation', '1'), 10);
  var quickHit = JSON.parse(await getConfig('mneme_quick_hit', '[10,1500,50,40]'));
  var comboHit = JSON.parse(await getConfig('mneme_combo_hit', '[50,3000,50,50]'));
  var quickHitMessages = JSON.parse(await getConfig('mneme_quick_hit_messages', '["NICE WORK|{count}"]'));
  var comboHitMessages = JSON.parse(await getConfig('mneme_combo_hit_messages', '["NICE WORK|{count}"]'));

  var quickTrigger = quickHit[0];
  var quickDuration = quickHit[1];
  var quickPosition = quickHit[2];
  var quickFontSize = quickHit[3] || 40;
  var comboTrigger = comboHit[0];
  var comboDuration = comboHit[1];
  var comboPosition = comboHit[2];
  var comboFontSize = comboHit[3] || 50;
  var motivationEnabled = hitMotivation === 1;

  if (isAndroid) {
    setTimeout(initRemoteBridge, 0);
  }

  function getRandomText(textArray) {
    if (!Array.isArray(textArray) || textArray.length === 0) {
      return "NICE WORK|{count}";
    }
    var randomIndex = Math.floor(Math.random() * textArray.length);
    return textArray[randomIndex];
  }

  // Parse message format: subtitle|title
  function parseMessage(template, count) {
    const selectedText = getRandomText(template);

    const processed = selectedText.replace(/\{count\}/g, count);

    // Split into two parts using |: subtitle|title
    const parts = processed.split('|');
    if (parts.length >= 2) {
      return {
        type: 'hierarchy',
        subtitle: parts[0] ? parts[0].trim() : '',
        title: parts[1] ? parts[1].trim() : ''
      };
    } else {
      return { type: 'single', content: processed.trim() };
    }
  }

  function shouldDimMotivationPopup() {
    return androidSessionFallbackActive;
  }

  // Center popup display - hierarchical design
  function showCenterPopup(message, isLong = false, count = 1) {
    const popup = document.createElement('div');
    const baseFontSize = isLong ? comboFontSize : quickFontSize;
    const duration = isLong ? comboDuration : quickDuration;
    const position = isLong ? comboPosition : quickPosition;

    const parsed = parseMessage(message, count);

    const dimForSessionFallback = shouldDimMotivationPopup();

    if (parsed.type === 'single') {
      popup.innerHTML = parsed.content;
      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        font-size: ${baseFontSize * 2}px;
        font-weight: bold;
        color: var(--text-primary, #333);
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;
    } else {
      popup.innerHTML = `
        <div class="milestone-subtitle">${parsed.subtitle}</div>
        <div class="milestone-title">${parsed.title}</div>
      `;

      popup.style.cssText = `
        position: fixed;
        top: ${position}%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99999;
        text-align: center;
        animation: containerFadeInOut ${duration/1000}s forwards;
      `;

      // Set different multiplier ratios based on type
      const subtitleMultiplier = isLong ? 0.7 : 0.5;  // Combo subtitle slightly larger
      const titleMultiplier = isLong ? 2.2 : 1.8;     // Combo title larger

      // Set subtitle style: small, thin, gray
      const subtitle = popup.querySelector('.milestone-subtitle');
      if (subtitle) {
        subtitle.style.cssText = `
          font-size: ${baseFontSize * subtitleMultiplier}px;
          font-weight: normal;
          color: var(--text-secondary, #666);
          letter-spacing: 2px;
          text-transform: uppercase;
          margin-bottom: 10px;
          animation: subtitleAppear 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.1s;
          opacity: 0;
        `;
      }

      // Set title style: large, bold, white
      const title = popup.querySelector('.milestone-title');
      if (title) {
        title.style.cssText = `
          font-size: ${baseFontSize * titleMultiplier}px;
          font-weight: bold;
          color: var(--text-primary, #333);
          line-height: 1.1;
          animation: titleAppear 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          animation-delay: 0.3s;
          opacity: 0;
        `;
      }
    }

    if (dimForSessionFallback) {
      popup.style.setProperty('--motivation-visible-opacity', '0.5');
    }

    document.body.appendChild(popup);

    setTimeout(() => {
      if (popup.parentNode) {
        popup.parentNode.removeChild(popup);
      }
    }, duration);
  }

  function getResetKey() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // If current time is before 4 AM, use previous day's date as reset key
    if (now.getHours() < 4) {
      today.setDate(today.getDate() - 1);
    }

    return today.toDateString();
  }

  async function checkAndResetCount() {
    const currentResetKey = getResetKey();
    const lastResetKey = await getValue('omt_last_reset', '');

    if (!lastResetKey) {
      await setValue('omt_last_reset', currentResetKey);
      return currentTotal;
    }

    if (currentResetKey !== lastResetKey) {
      await setValue('omt_last_reset', currentResetKey);
      await setCount(0, 'ÊØèÊó•ÈáçÁΩÆ');
      appendLog('ÊØèÊó•ÈáçÁΩÆÔºåËÆ°Êï∞Ê∏ÖÈõ∂');
      return 0;
    }

    return currentTotal;
  }

  async function getCount() {
    await checkAndResetCount();
    return currentTotal;
  }

  async function setCount(count, summaryNote) {
    currentTotal = count;
    persistLocalCount();
    updateStorageSummary(summaryNote);
    if (isAndroid) {
      queueRemoteUpdate(LOCAL_COUNT_KEY, count.toString());
    }
  }

  // ===== Deduplication: Track last 4 unique words =====
  async function getRecentWords() {
    const wordsJson = await getValue('omt_recent_words', '[]');
    try {
      return JSON.parse(wordsJson);
    } catch (e) {
      return [];
    }
  }

  async function isRecentWord(word) {
    const recentWords = await getRecentWords();
    return recentWords.indexOf(word) !== -1;
  }

  async function addRecentWord(word) {
    let recentWords = await getRecentWords();

    // Remove word if already exists (to maintain uniqueness)
    const index = recentWords.indexOf(word);
    if (index !== -1) {
      recentWords.splice(index, 1);
    }

    // Add new word to the end
    recentWords.push(word);

    // Keep only last 4 unique words
    if (recentWords.length > 4) {
      recentWords.shift();
    }

    await setValue('omt_recent_words', JSON.stringify(recentWords));
  }

  // Get current word from template field
  const currentWord = '{{Word}}';

  // Trigger count only if this is a new word (not recently seen)
  if (!await isRecentWord(currentWord)) {
    const currentCount = await getCount() + 1;
    await setCount(currentCount, 'Session +1');
    await addRecentWord(currentWord);

    appendLog('Session ËÆ°Êï∞Êõ¥Êñ∞ -> ' + currentCount);

    if (motivationEnabled) {
      if (currentCount % comboTrigger === 0) {
        showCenterPopup(comboHitMessages, true, currentCount);
      } else if (currentCount % quickTrigger === 0) {
        showCenterPopup(quickHitMessages, false, currentCount);
      }
    }
  } else {
    const currentCount = await getCount();
    updateStorageSummary('ÈáçÂ§çÂçïËØç');
    appendLog('ÈáçÂ§çÂçïËØçÔºåËÆ°Êï∞‰øùÊåÅ ' + currentCount);
  }
  })();
</script>
